// Â© sbtnc
// Created: 2024-03-10
// Last modified: 2024-06-17
// Version 1.0

// @version=5
indicator("Multi-Timeframe Separators", "MTF Separators", overlay = true, max_lines_count = 500)


//--------------------------------------------------------------------
//#region                      Constants
//--------------------------------------------------------------------

color   COLOR_1 = color.green
color   COLOR_2 = color.orange
color   COLOR_3 = color.red
color   COLOR_4 = color.blue

//#endregion


//--------------------------------------------------------------------
//#region                        Inputs
//--------------------------------------------------------------------

string g1    = "Separators"
string opt1  = "5 seconds"
string opt2  = "10 seconds"
string opt3  = "15 seconds"
string opt4  = "30 seconds"
string opt5  = "1 minute"
string opt6  = "2 minutes"
string opt7  = "3 minutes"
string opt8  = "5 minutes"
string opt9  = "10 minutes"
string opt10 = "15 minutes"
string opt11 = "30 minutes"
string opt12 = "1 hour"
string opt13 = "2 hours"
string opt14 = "3 hours"
string opt15 = "4 hours"
string opt16 = "6 hours"
string opt17 = "8 hours"
string opt18 = "12 hours"
string opt19 = "1 day"
string opt20 = "1 week"
string opt21 = "1 month"
string opt22 = "3 months"
string opt23 = "6 months"
string opt24 = "12 months"

enableSeparatorInput1       = input.bool    (true,      "",     group = g1, inline = "#1")
separatorTimeframeInput1    = input.string  (opt19,     "",     group = g1, inline = "#1", options = [opt1, opt2, opt3, opt4, opt5, opt6, opt7, opt8, opt9, opt10, opt11, opt12, opt13, opt14, opt15, opt16, opt17, opt18, opt19, opt20, opt21, opt22, opt23, opt24])
separatorLookbackInput1     = input.int     (50,        "",     group = g1, inline = "#1", minval = 1, maxval = 500, display = display.none)
enableSeparatorInput2       = input.bool    (true,      "",     group = g1, inline = "#2")
separatorTimeframeInput2    = input.string  (opt20,     "",     group = g1, inline = "#2", options = [opt1, opt2, opt3, opt4, opt5, opt6, opt7, opt8, opt9, opt10, opt11, opt12, opt13, opt14, opt15, opt16, opt17, opt18, opt19, opt20, opt21, opt22, opt23, opt24])
separatorLookbackInput2     = input.int     (50,        "",     group = g1, inline = "#2", minval = 1, maxval = 500, display = display.none)
enableSeparatorInput3       = input.bool    (true,      "",     group = g1, inline = "#3")
separatorTimeframeInput3    = input.string  (opt21,     "",     group = g1, inline = "#3", options = [opt1, opt2, opt3, opt4, opt5, opt6, opt7, opt8, opt9, opt10, opt11, opt12, opt13, opt14, opt15, opt16, opt17, opt18, opt19, opt20, opt21, opt22, opt23, opt24])
separatorLookbackInput3     = input.int     (50,        "",     group = g1, inline = "#3", minval = 1, maxval = 500, display = display.none)
enableSeparatorInput4       = input.bool    (false,     "",     group = g1, inline = "#4")
separatorTimeframeInput4    = input.string  (opt24,     "",     group = g1, inline = "#4", options = [opt1, opt2, opt3, opt4, opt5, opt6, opt7, opt8, opt9, opt10, opt11, opt12, opt13, opt14, opt15, opt16, opt17, opt18, opt19, opt20, opt21, opt22, opt23, opt24])
separatorLookbackInput4     = input.int     (50,        "",     group = g1, inline = "#4", minval = 1, maxval = 500, display = display.none)

string g2 = "Style"

separatorColorInput1        = input.color   (COLOR_1,   "",     group = g2, inline = "#1")
separatorWidthInput1        = input.int     (1,         "",     group = g2, inline = "#1", minval = 1, display = display.none)
separatorStyleInput1        = input.string  ("Dotted",  "",     group = g2, inline = "#1", options =["Solid", "Dashed", "Dotted"], display = display.none)
separatorColorInput2        = input.color   (COLOR_2,   "",     group = g2, inline = "#2")
separatorWidthInput2        = input.int     (1,         "",     group = g2, inline = "#2", minval = 1, display = display.none)
separatorStyleInput2        = input.string  ("Solid",   "",     group = g2, inline = "#2", options =["Solid", "Dashed", "Dotted"], display = display.none)
separatorColorInput3        = input.color   (COLOR_3,   "",     group = g2, inline = "#3")
separatorWidthInput3        = input.int     (2,         "",     group = g2, inline = "#3", minval = 1, display = display.none)
separatorStyleInput3        = input.string  ("Solid",   "",     group = g2, inline = "#3", options =["Solid", "Dashed", "Dotted"], display = display.none)
separatorColorInput4        = input.color   (COLOR_4,   "",     group = g2, inline = "#4")
separatorWidthInput4        = input.int     (3,         "",     group = g2, inline = "#4", minval = 1, display = display.none)
separatorStyleInput4        = input.string  ("Solid",   "",     group = g2, inline = "#4", options =["Solid", "Dashed", "Dotted"], display = display.none)

string g3               = "Preferences"
string refOpt1          = "Session Time"
string refOpt2          = "Day Time"
string referenceTooltip = "By default, the indicator uses the start of the trading session as a point of reference. " +
                         "See \"Security Info\" for more details.\n\n" + 
                         "In some markets, when the start of the trading session differs from the start of the day, " +
                         "you can use the \"Day Time\" option to prefer 00:00 instead.\n\n" +
                         "For example, the trading session on S&P500 is from 09:30 to 16:10 New York time. " +
                         "Drawing 2 hours separators produces for \"Session Time\" the intervals [09:30, 11:30, 13:30, 15:30] " +
                         "like the bars seen on the 2h chart, or for \"Day Time\" the intervals [10:00, 12:00, 14:00, 16:00]."       
string timezoneTooltip  = "By default, the indicator uses the exchange timezone. See \"Security Info\" for more details.\n\n" +
                         "When using the \"Day Time\" option as a reference, you can choose a particular timezone to determine the start of the day.\n\n" +
                         "Note: this implies looking at minutes data and might reduce the number of separators on higher timeframes charts."

referenceInput              = input.string  (refOpt1,       "Reference",    group = g3, tooltip = referenceTooltip, options = [refOpt2, refOpt1])
timezoneInput               = input.string  ("Exchange",    "Timezone",     group = g3, tooltip = timezoneTooltip, options = [
     "UTC",
     "Exchange",
     "Africa/Cairo",
     "Africa/Johannesburg",
     "Africa/Lagos",
     "Africa/Nairobi",
     "Africa/Tunis",
     "America/Argentina/Buenos_Aires",
     "America/Bogota",
     "America/Caracas",
     "America/Chicago",
     "America/Denver",
     "America/El_Salvador",
     "America/Juneau",
     "America/Lima",
     "America/Los_Angeles",
     "America/New_York",
     "America/Mexico_City",
     "America/Phoenix",
     "America/Santiago",
     "America/Sao_Paulo",
     "America/Toronto",
     "America/Vancouver",
     "Asia/Almaty",
     "Asia/Ashgabat",
     "Asia/Bahrain",
     "Asia/Bangkok",
     "Asia/Dubai",
     "Asia/Chongqing",
     "Asia/Colombo",
     "Asia/Ho_Chi_Minh",
     "Asia/Hong_Kong",
     "Asia/Istanbul",
     "Asia/Jakarta",
     "Asia/Jerusalem",
     "Asia/Karachi",
     "Asia/Kathmandu",
     "Asia/Kolkata",
     "Asia/Kuwait",
     "Asia/Manila",
     "Asia/Muscat",
     "Asia/Nicosia",
     "Asia/Qatar",
     "Asia/Riyadh",
     "Asia/Seoul",
     "Asia/Shanghai",
     "Asia/Singapore",
     "Asia/Taipei",
     "Asia/Tehran",
     "Asia/Tokyo",
     "Asia/Yangon",
     "Atlantic/Reykjavik",
     "Australia/Adelaide",
     "Australia/Brisbane",
     "Australia/Perth",
     "Australia/Sydney",
     "Europe/Amsterdam",
     "Europe/Athens",
     "Europe/Belgrade",
     "Europe/Berlin",
     "Europe/Bratislava",
     "Europe/Brussels",
     "Europe/Bucharest",
     "Europe/Budapest",
     "Europe/Copenhagen",
     "Europe/Dublin",
     "Europe/Helsinki",
     "Europe/Madrid",
     "Europe/Malta",
     "Europe/Moscow",
     "Europe/Lisbon",
     "Europe/London",
     "Europe/Luxembourg",
     "Europe/Oslo",
     "Europe/Paris",
     "Europe/Riga",
     "Europe/Rome",
     "Europe/Stockholm",
     "Europe/Tallinn",
     "Europe/Vilnius",
     "Europe/Warsaw",
     "Europe/Zurich",
     "Pacific/Auckland",
     "Pacific/Chatham",
     "Pacific/Fakaofo",
     "Pacific/Honolulu",
     "Pacific/Norfolk"
     ],
     display = display.none
 )

//#endregion


//--------------------------------------------------------------------
//#region                   Functions & methods
//--------------------------------------------------------------------

// @function Produce the `timeframe` parameter from the user timeframe input.
// @returns  string
method tf(simple string input) =>
    switch input 
        "5 seconds"  => "5S"
        "10 seconds" => "10S"
        "15 seconds" => "15S"
        "30 seconds" => "30S"
        "1 minute"   => "1"
        "2 minutes"  => "2"
        "3 minutes"  => "3"
        "5 minutes"  => "5"
        "10 minutes" => "10"
        "15 minutes" => "15"
        "30 minutes" => "30"
        "1 hour"     => "60"
        "2 hours"    => "120"
        "3 hours"    => "180"
        "4 hours"    => "240"
        "6 hours"    => "360"
        "8 hours"    => "480"
        "12 hours"   => "720"
        "1 day"      => "1D"
        "1 week"     => "1W"
        "1 month"    => "1M" 
        "3 months"   => "3M"
        "6 months"   => "6M"
        "12 months"  => "12M"


// @function Produce the `timezone` parameter from the given user input.
// @returns  string
getTimezone(simple string input) =>
    switch input
        "UTC"       => "UTC+0"
        "Exchange"  => syminfo.timezone  
        => input


// @function Get the line `style` parameter from the given user input.
// @returns  string
getLineStyle(string input) =>
    switch input
        "Solid"     => line.style_solid
        "Dotted"    => line.style_dotted
        "Dashed"    => line.style_dashed


// @function Get the separator times counted from midnight.
// @returns  array<int> 
getTimes(int multiplier, int total) =>
    array<int> _timeArray = array.new_int()
    for i = 0 to total -1 by multiplier
        _timeArray.push(i)
    _timeArray


// @function Check if the current bar year changed.
// @returns  bool
yearChange(string tz) =>
    ta.change(year(time, tz)) > 0


// @function Check if the current bar month changed.
// @returns  bool
monthChange(string tz) =>
    not na(time[1]) and month(time[1], tz) != month(time, tz) // can't catch if same month but missing a whole year (use timestamp diff ?)


monthChange(int multiplier, string tz) =>
    var array<int> _monthArray = getTimes(multiplier, 12)
    not na(time[1]) and month(time[1], tz) != month(time, tz) and _monthArray.includes(month(time, tz)) // can't catch if missing multplied months or more


// @function Check if the current bar week changed
// @returns  bool
weekChange(string tz) =>
    not na(time[1]) and weekofyear(time[1], tz) != weekofyear(time, tz)  // can't catch if same week but missing a whole year (use timestamp diff ?)


// @function Check if the current bar day changed
// @returns  bool
dayChange(string tz) =>
    not na(time[1]) and dayofmonth(time[1], tz) != dayofmonth(time, tz) // can't catch if same day but missing a whole month/year (use timestamp diff ?)
 

// @function Check if the current bar hour changed
// @returns  bool
hourChange(string tz) =>
    not na(time[1]) and hour(time[1], tz) != hour(time, tz) // can't catch if same hour but missing a whole day/month/year (use timestamp diff ?)


hourChange(int multiplier, string tz) =>
    var array<int> _hourArray = getTimes(multiplier, 24)
    var int _last = na
    var int _intervalMs = multiplier * timeframe.in_seconds("60") * 1000
    int _hour = hour(time, tz)

    if (_hour[1] != _hour and _hourArray.includes(_hour)) or time - _last >= _intervalMs
        _last := time 

    ta.change(_last) > 0


// @function Check if the current bar minute changed
// @returns  bool
minuteChange() =>
    minute[1] != minute


minuteChange(int multiplier, string tz) =>
    var array<int> _minuteArray = getTimes(multiplier, 60)
    var int _last = na
    var int _intervalMs = multiplier * timeframe.in_seconds("1") * 1000
    int _minute = minute(time, tz)

    if (_minute[1] != _minute and _minuteArray.includes(_minute)) or time - _last >= _intervalMs
        _last := time 

    ta.change(_last) > 0


// @function Check if the current bar seconds changed
// @returns  bool
secondChange(int multiplier) =>
    var int _last = na
    int increment = multiplier * 1000

    // At the bar change
    if time % increment == 0
        _last := time
        //log.info("At {0}", str.format_time(_last))

    // Some bars were missing
    else if time - _last >= increment
        _last := time - time % increment
        //log.warning("Past {0} by {1}s", str.format_time(_last), (time % increment) / 1000)

    ta.change(_last)


// the functions execute when passing a time interval (abstract from the session)
// and we can pass a custom timezone. it affects at the level of 60min, and more rarely 30m and 15m
// we should recontruct from 00:00 expressed in the timezone (00:00 at +12:45UTC = 11:15 UTC) (or different session open=
// We can't use UNIX which is based on UTC
timeChange(string timeframe) =>
    var _tz = getTimezone(timezoneInput)
    
    switch timeframe
        "5S"  => secondChange   (5)
        "10S" => secondChange   (10)
        "15S" => secondChange   (15)
        "30S" => secondChange   (30)
        "1"   => minuteChange   ()
        "2"   => minuteChange   (2, _tz)
        "3"   => minuteChange   (3, _tz)
        "5"   => minuteChange   (5, _tz)
        "10"  => minuteChange   (10, _tz)
        "15"  => minuteChange   (15, _tz)
        "30"  => minuteChange   (30, _tz)
        "60"  => hourChange     (_tz)
        "120" => hourChange     (2, _tz)
        "180" => hourChange     (3, _tz)
        "240" => hourChange     (4, _tz)
        "360" => hourChange     (6, _tz)
        "480" => hourChange     (8, _tz)
        "720" => hourChange     (12, _tz)
        "1D"  => dayChange      (_tz)
        "1W"  => weekChange     (_tz)
        "1M"  => monthChange    (_tz)
        "3M"  => monthChange    (3, _tz)
        "6M"  => monthChange    (6, _tz)
        "12M" => yearChange     (_tz)


// @function Draw a separator line when the timeframe changed. 
// @returns  void
drawSeparator(array<bool> ltfChange, bool isEnabled, string timeframe, color color, int width, string style, int lookback) =>
    // @variable The collection of visible separators.
    var array<line> _separatorArray = array.new_line()
    // @variable Is true if plotting a higher timeframe separator.
    bool _canDisplayOnChart = isEnabled and timeframe.in_seconds(timeframe) > timeframe.in_seconds()

    if isEnabled and _canDisplayOnChart
        if ltfChange.some()
            _separatorArray.push(
                 line.new(
                     x1 = time,
                     y1 = open,
                     x2 = time,
                     // y1 and y2 must be distinct or otherwise result in a vertical line.
                     y2 = open + syminfo.mintick,
                     xloc = xloc.bar_time, 
                     extend = extend.both, 
                     color = color,
                     style = getLineStyle(style),
                     width = width
                     )
                 )

            // Trim the exceeding number of lines.
            if _separatorArray.size() > lookback
                line.delete(_separatorArray.shift())


method inSeconds(simple string timeframe) =>
    switch timeframe
        "1M"  => timeframe.ismonthly ? 1  * 2628003 : 30 * 24 * 60 * 60
        "3M"  => timeframe.ismonthly ? 3  * 2628003 : 3 * 30 * 24 * 60 * 60
        "6M"  => timeframe.ismonthly ? 6  * 2628003 : 6 * 30 * 24 * 60 * 60
        "12M" => timeframe.ismonthly ? 12 * 2628003 : 12 * 30 * 24 * 60 * 60
        => timeframe.in_seconds(timeframe)


//    switch timeframe
//        "5S"  => 5
//        "10S" => 10
//        "15S" => 15
//        "30S" => 30
//        "1"   => 1   *60
//        "2"   => 2   *60
//        "3"   => 3   *60
//        "5"   => 5   *60
//        "10"  => 10  *60
//        "15"  => 15  *60
//        "30"  => 30  *60
//        "45"  => 45  *60
//        "60"  => 60  *60  
//        "120" => 120 *60 
//        "180" => 180 *60 
//        "240" => 240 *60 
//        "360" => 360 *60 
//        "480" => 480 *60 
//        "720" => 720 *60 
//        "1D"  => 24 * 60 * 60
//        "1W"  => 7 * 24 * 60 *60
//        "1M"  => timeframe.ismonthly ? 2628003 : 30 * 24 * 60 * 60
//        "3M"  => timeframe.ismonthly ? 3 *2628003 : 3 * 30 * 24 * 60 * 60
//        "6M"  => timeframe.ismonthly ? 6 *2628003 : 6 * 30 * 24 * 60 * 60
//        "12M" => timeframe.ismonthly ? 12 * 2628003 : 12 * 30 * 24 * 60 * 60


getLtf(simple int a, simple int b) =>
    simple string tf = if a % b != 0
        int _a = a
        int _tempA = na
        int _b = b
        int _tempB = na

        while (_a % _b) != 0
            if (_a % _b ) != 0
                _tempA := _a
                _a := _b
                _b := _tempA % _b

        timeframe.from_seconds(_b)
    else 
        timeframe.period

//#endregion


//--------------------------------------------------------------------
//#region                 Variables declarations
//--------------------------------------------------------------------

tz = getTimezone(timezoneInput)

sameTimezone = tz == syminfo.timezone

var simple string timeframe1 = separatorTimeframeInput1.tf()
var simple string timeframe2 = separatorTimeframeInput2.tf()
var simple string timeframe3 = separatorTimeframeInput3.tf()
var simple string timeframe4 = separatorTimeframeInput4.tf()

bool baseOnSessionInput = referenceInput == refOpt1

//#endregion


//--------------------------------------------------------------------
//#region                         Logic
//--------------------------------------------------------------------

tf1 = getLtf(timeframe1.inSeconds(), timeframe.in_seconds())
tf2 = getLtf(timeframe2.inSeconds(), timeframe.in_seconds())
tf3 = getLtf(timeframe3.inSeconds(), timeframe.in_seconds())
tf4 = getLtf(timeframe4.inSeconds(), timeframe.in_seconds())

// If we use a timezone, we must use at max 15/30/60min data
ltf1 = (not baseOnSessionInput) and (not sameTimezone) and (timeframe.in_seconds(tf1) > timeframe.in_seconds("15")) ? "15" : tf1
ltf2 = (not baseOnSessionInput) and (not sameTimezone) and (timeframe.in_seconds(tf2) > timeframe.in_seconds("15")) ? "15" : tf2
ltf3 = (not baseOnSessionInput) and (not sameTimezone) and (timeframe.in_seconds(tf3) > timeframe.in_seconds("15")) ? "15" : tf3
ltf4 = (not baseOnSessionInput) and (not sameTimezone) and (timeframe.in_seconds(tf4) > timeframe.in_seconds("15")) ? "15" : tf4

cond1 = enableSeparatorInput1 ? (not baseOnSessionInput ? timeChange(timeframe1) : timeframe.change(timeframe1)) : na
cond2 = enableSeparatorInput2 ? (not baseOnSessionInput ? timeChange(timeframe2) : timeframe.change(timeframe2)) : na
cond3 = enableSeparatorInput3 ? (not baseOnSessionInput ? timeChange(timeframe3) : timeframe.change(timeframe3)) : na
cond4 = enableSeparatorInput4 ? (not baseOnSessionInput ? timeChange(timeframe4) : timeframe.change(timeframe4)) : na

ltfTimeArray1 = request.security_lower_tf(syminfo.tickerid, ltf1, cond1)
ltfTimeArray2 = request.security_lower_tf(syminfo.tickerid, ltf2, cond2)
ltfTimeArray3 = request.security_lower_tf(syminfo.tickerid, ltf3, cond3)
ltfTimeArray4 = request.security_lower_tf(syminfo.tickerid, ltf4, cond4)

//#endregion


//--------------------------------------------------------------------
//#region                        Visuals
//--------------------------------------------------------------------

drawSeparator(ltfTimeArray1, enableSeparatorInput1, timeframe1, separatorColorInput1, separatorWidthInput1, separatorStyleInput1, separatorLookbackInput1)
drawSeparator(ltfTimeArray2, enableSeparatorInput2, timeframe2, separatorColorInput2, separatorWidthInput2, separatorStyleInput2, separatorLookbackInput2)
drawSeparator(ltfTimeArray3, enableSeparatorInput3, timeframe3, separatorColorInput3, separatorWidthInput3, separatorStyleInput3, separatorLookbackInput3)
drawSeparator(ltfTimeArray4, enableSeparatorInput4, timeframe4, separatorColorInput4, separatorWidthInput4, separatorStyleInput4, separatorLookbackInput4)

//#endregion


//--------------------------------------------------------------------
//#region                         Alerts
//--------------------------------------------------------------------
//#endregion


//--------------------------------------------------------------------
//#region                         Debug
//--------------------------------------------------------------------

//if barstate.islast
//    label.new(bar_index, high, str.format("{0} {1} == {2}", sameTimezone, tz, syminfo.timezone))


// Table

// @function Return the display string of the user timeframe input
// @returns  string
method displayString(string this) =>
    string _tf = this == "" ? timeframe.period : this
    switch _tf
        "S"     => "1 second"
        "1S"    => "1 second"
        "5S"    => "5 seconds"
        "10S"   => "10 seconds"
        "15S"   => "15 seconds"
        "30S"   => "30 seconds"
        "1"     => "1 minute"
        "2"     => "2 minutes"
        "3"     => "3 minutes"
        "5"     => "5 minutes"
        "10"    => "10 minutes"
        "15"    => "15 minutes"
        "30"    => "30 minutes"
        "45"    => "45 minutes"
        "60"    => "1 hour"
        "120"   => "2 hours"
        "180"   => "3 hours"
        "240"   => "4 hours"
        "360"   => "6 hours"
        "480"   => "8 hours"
        "720"   => "12 hours"
        "1440"  => "24 hours"
        "D"     => "1 day"
        "1D"    => "1 day"
        "W"     => "1 week"
        "1W"    => "1 week"
        "M"     => "1 month"
        "1M"    => "1 month"
        "3M"    => "3 months"
        "6M"    => "6 months"
        "12M"   => "12 months"

if barstate.islast
    var table t = table.new(position.bottom_right, 3, 5)

    t.cell(0, 0, "Chart", text_color = chart.fg_color)
    t.cell(1, 0, "Separator", text_color = chart.fg_color)
    t.cell(2, 0, "Intrabar", text_color = chart.fg_color)

    if enableSeparatorInput1
        t.cell(0, 1, timeframe.period.displayString(), text_color = chart.fg_color)
        t.cell(1, 1, separatorTimeframeInput1, text_color = chart.fg_color)
        t.cell(2, 1, ltf1.displayString(), text_color = timeframe1.inSeconds() % timeframe.in_seconds() != 0 ? color.red : chart.fg_color)

    if enableSeparatorInput2
        t.cell(0, 2, timeframe.period.displayString(), text_color = chart.fg_color)
        t.cell(1, 2, separatorTimeframeInput2, text_color = chart.fg_color)
        t.cell(2, 2, ltf2.displayString(), text_color = timeframe2.inSeconds() % timeframe.in_seconds() != 0 ? color.red : chart.fg_color)

    if enableSeparatorInput3
        t.cell(0, 3, timeframe.period.displayString(), text_color = chart.fg_color)
        t.cell(1, 3, separatorTimeframeInput3, text_color = chart.fg_color)
        t.cell(2, 3, ltf3.displayString(), text_color = timeframe3.inSeconds() % timeframe.in_seconds() != 0 ? color.red : chart.fg_color)

    if enableSeparatorInput4
        t.cell(0, 4, timeframe.period.displayString(), text_color = chart.fg_color)
        t.cell(1, 4, separatorTimeframeInput4, text_color = chart.fg_color)
        t.cell(2, 4, ltf4.displayString(), text_color = timeframe4.inSeconds() % timeframe.in_seconds() != 0 ? color.red : chart.fg_color)

//#endregion


//--------------------------------------------------------------------
//#region                      Performances
//--------------------------------------------------------------------

//import PineCoders/LibraryStopwatch/1
//
//[timePerBarInMs, totalTimeInMs, barsTimed, barsNotTimed] = LibraryStopwatch.stopwatchStats()
//
//
//// Table
//
//if barstate.islast
//    var table t = table.new(position.top_right, 1, 1)
//    var txt = str.tostring(timePerBarInMs, "ms/bar: #.######\n") +
//              str.tostring(totalTimeInMs, "Total time (ms): #,###.######\n") + 
//              str.tostring(barsTimed + barsNotTimed, "Bars analyzed: #")
//    table.cell(t, 0, 0, txt, bgcolor = color.yellow, text_halign = text.align_right)

//#endregion

