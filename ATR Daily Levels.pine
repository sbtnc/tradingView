// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© sbtnc
// Created: 2020-09-06
// Last modified: 2022-05-01
// Version 4.0

// @version=5
indicator("Daily ATR Levels", "D ATR", true)


//--------------------------------------------------------------------
//                             Constants
//--------------------------------------------------------------------

var DEFAULT_COLOR           = color.gray
var DEFAULT_HIGHLIGHT_COLOR = color.new(DEFAULT_COLOR, 60)
var DEFAULT_OFFSET_START    = 1
var DEFAULT_LINE_STYLE      = line.style_dotted
var DEFAULT_LINE_WIDTH      = 2
var DEFAULT_LINE_LENGTH     = 8
var DEFAULT_LABEL_STYLE     = label.style_label_left
var DEFAULT_LABEL_COLOR     = color(na)


//--------------------------------------------------------------------
//                               Inputs
//--------------------------------------------------------------------

var g_indicator     = "ATR"
var g_style         = "Style"

var i_period        = input        (20,                          "Length",                               group=g_indicator)
var i_value         = input.string ("Yesterday",                 "Reference", ["Today", "Yesterday"],    group=g_indicator)
var i_color         = input        (DEFAULT_COLOR,               "Color",                                group=g_style)
var i_overflowColor = input        (DEFAULT_HIGHLIGHT_COLOR,     "Overflow Color",                       group=g_style)
var i_startOffset   = input        (true,                        "Show Start Offset",                    group=g_style)


//--------------------------------------------------------------------
//                        Variables declarations
//--------------------------------------------------------------------

var float dayHigh = na
var float dayLow = na

[dayOpen, prevDayClose, dayTime, dayATR] = request.security(
      syminfo.tickerid,
      'D',
      [open, close[1], time, ta.atr(i_period)[i_value == "Yesterday" ? 1 : 0]],
      lookahead = barmerge.lookahead_on)

// For avoiding unexpected behaviors, don't display the indicator when requesting data from lower time frames
can_display_timeframe       = not (timeframe.isweekly or timeframe.ismonthly)

var line atr_high_line      = na
var line atr_low_line       = na
var label atr_high_label    = na
var label atr_low_label     = na


//--------------------------------------------------------------------
//                              Functions 
//--------------------------------------------------------------------

f_hasGapped(_open, _prevClose) => _open != _prevClose

f_getTopPrice(_open, _prevClose, _high) => f_hasGapped(_open, _prevClose) ? _prevClose > _high ? _prevClose : _high : _high

f_getBottomPrice(_open, _prevClose, _low) => f_hasGapped(_open, _prevClose) ? _prevClose < _low ? _prevClose : _low : _low

// get consistent bar time difference (ignoring weekends and holidays)
f_getMinTimeDiff() => math.min(time - time[1], time[1] - time[2])


//--------------------------------------------------------------------
//                                Logic
//--------------------------------------------------------------------

// Collect the daily high and low on runtime instead of fetching them from a security call
// It aims to avoid the initial `future leak` from the "jump" when using the bar replay function

// Init on the first bar / reset on following day change
if not (dayTime == dayTime[1])
    dayHigh := high
    dayLow := low

// Tracks newest high and low
if high > dayHigh
    dayHigh := high
if low < dayLow
    dayLow := low


// Computes ATR levels prices

atr_high = f_getBottomPrice(dayOpen, prevDayClose, dayLow) + dayATR
atr_low = f_getTopPrice(dayOpen, prevDayClose, dayHigh) - dayATR



//--------------------------------------------------------------------
//                          Plotting & styling
//--------------------------------------------------------------------

bar = nz(f_getMinTimeDiff())

if barstate.islast and can_display_timeframe

    // levels positioning
    offset              = time + bar * DEFAULT_OFFSET_START
    level_start         = i_startOffset ? offset : dayTime
    level_end           = i_startOffset ? level_start + bar * DEFAULT_LINE_LENGTH : offset + bar * DEFAULT_LINE_LENGTH

    // when price is passed the upper or lower, this last gets highlighted
    level_high_color    = day_high > atr_high ? i_overflowColor : i_color
    level_low_color     = day_low < atr_low ? i_overflowColor : i_color
    
    // levels

    atr_high_line := line.new(
     x1     = level_start,
     x2     = level_end,
     y1     = atr_high,
     y2     = atr_high,
     xloc   = xloc.bar_time,
     style  = DEFAULT_LINE_STYLE,
     color  = level_high_color,
     width  = DEFAULT_LINE_WIDTH)
    
    atr_low_line := line.new(
     x1     = level_start,
     x2     = level_end,
     y1     = atr_low,
     y2     = atr_low,
     xloc   = xloc.bar_time,
     style  = DEFAULT_LINE_STYLE,
     color  = level_low_color,
     width  = DEFAULT_LINE_WIDTH)
    
    atrStr = str.tostring(dayATR, format.mintick)
    upperPriceStr = str.tostring(atr_high, format.mintick)
    lowerPriceStr = str.tostring(atr_low, format.mintick)

    upperLabelText = str.format("{0} ({1})", upperPriceStr, atrStr)
    LowerLabelText = lowerPriceStr

    // labels

    atr_high_label := label.new(
     x          = level_end,
     y          = atr_high,
     text       = upperLabelText,
     xloc       = xloc.bar_time,
     color      = DEFAULT_LABEL_COLOR,
     style      = DEFAULT_LABEL_STYLE,
     textcolor  = level_high_color)
    
    atr_low_label := label.new(
     x          = level_end,
     y          = atr_low,
     text       = LowerLabelText,
     xloc       = xloc.bar_time,
     color      = DEFAULT_LABEL_COLOR,
     style      = DEFAULT_LABEL_STYLE,
     textcolor  = level_low_color)
    
    // fix multiple drawings on the current candle update
    line.delete(atr_high_line[1])
    line.delete(atr_low_line[1])
    label.delete(atr_high_label[1])
    label.delete(atr_low_label[1])